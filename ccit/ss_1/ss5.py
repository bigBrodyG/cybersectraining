#!/usr/bin/env python3

# dati forniti
xa = (
    b'\x60\x0c\x10\x00\x00\x00\x00\x00'
    b'\x64\x0c\x10\x00\x00\x00\x00\x00'
    b'\x68\x0c\x10\x00\x00\x00\x00\x00'
    b'\x6c\x0c\x10\x00\x00\x00\x00\x00'
    b'\x6f\x0c\x10\x00\x00\x00\x00\x00'
    b'\x73\x0c\x10\x00\x00\x00\x00\x00'
    b'\x77\x0c\x10\x00\x00\x00\x00\x00'
    b'\x7b\x0c\x10\x00\x00\x00\x00\x00'
    b'\x7f\x0c\x10\x00\x00\x00\x00\x00'
    b'\x83\x0c\x10\x00\x00\x00\x00\x00'
    b'\x87\x0c\x10\x00\x00\x00\x00\x00'
    b'\x8b\x0c\x10\x00\x00\x00\x00\x00'
    b'\x8f\x0c\x10\x00\x00\x00\x00\x00'
    b'\x93\x0c\x10\x00\x00\x00\x00\x00'
    b'\x97\x0c\x10\x00\x00\x00\x00\x00'
    b'\x9b\x0c\x10\x00\x00\x00\x00\x00'
    b'\x9f\x0c\x10\x00\x00\x00\x00\x00'
    b'\xa3\x0c\x10\x00\x00\x00\x00\x00'
    b'\xa7\x0c\x10\x00\x00\x00\x00\x00'
    b'\xab\x0c\x10\x00\x00\x00\x00\x00'
    b'\xaf\x0c\x10\x00\x00\x00\x00\x00'
    b'\xb3\x0c\x10\x00\x00\x00\x00\x00'
    b'\xb7\x0c\x10\x00\x00\x00\x00\x00'
    b'\xbb\x0c\x10\x00\x00\x00\x00\x00'
    b'\xbf\x0c\x10\x00\x00\x00\x00\x00'
    b'\xc3\x0c\x10\x00\x00\x00\x00\x00'
)

# estraiamo per ogni blocco (26 totali) i primi 3 byte attesi
expected = [ xa[i*8:i*8+3] for i in range(26) ]

# array "key" (26 interi in little-endian)
key_bytes = (
    b'\x0a\x00\x00\x00'
    b'\x05\x00\x00\x00'
    b'\x00\x00\x00\x00'
    b'\x19\x00\x00\x00'
    b'\x04\x00\x00\x00'
    b'\x0e\x00\x00\x00'
    b'\x15\x00\x00\x00'
    b'\x16\x00\x00\x00'
    b'\x08\x00\x00\x00'
    b'\x06\x00\x00\x00'
    b'\x02\x00\x00\x00'
    b'\x09\x00\x00\x00'
    b'\x0b\x00\x00\x00'
    b'\x0c\x00\x00\x00'
    b'\x0d\x00\x00\x00'
    b'\x17\x00\x00\x00'
    b'\x13\x00\x00\x00'
    b'\x10\x00\x00\x00'
    b'\x0f\x00\x00\x00'
    b'\x03\x00\x00\x00'
    b'\x14\x00\x00\x00'
    b'\x11\x00\x00\x00'
    b'\x18\x00\x00\x00'
    b'\x12\x00\x00\x00'
    b'\x01\x00\x00\x00'
    b'\x07\x00\x00\x00'
)
import struct
key_ints = [struct.unpack('<I', key_bytes[i*4:i*4+4])[0] for i in range(26)]
# calcoliamo gli offset: ogni offset = key[i] * 3
offsets = [k * 3 for k in key_ints]

# Creiamo un array di byte lungo 78 (gli indici 0..77)
# NOTA: La lunghezza totale necessaria (coprendo offset fino a 75 + 3 = 78) è 78 byte.
input_arr = bytearray(b'?' * 78)  # inizializziamo con un carattere placeholder

# Per ciascun i, inseriamo il blocco atteso (3 byte) all'offset calcolato
for i, off in enumerate(offsets):
    # inseriamo gli expected[i] (3 byte) in input_arr[off : off+3]
    input_arr[off:off+3] = expected[i]

# Ora input_arr è la stringa corretta (di 78 byte)
# Se si vuole una stringa senza eventuali "?" nei byte non vincolati, controlliamo l'overlap:
# In questo caso le posizioni sono disposte in modo continuo dagli offset minore al massimo.
# Possiamo stampare il risultato in esadecimale:
print("L'input (78 byte) corretto in hex:")
print(input_arr.hex())

# Se desideri visualizzarlo (non necessariamente ASCII) puoi farlo:
print("L'input (78 byte) corretto come bytes:")
print(input_arr)
