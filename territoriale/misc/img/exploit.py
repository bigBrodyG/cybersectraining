#!/usr/bin/env python3

import sys
import os
import glob
from hashlib import sha256
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

if len(sys.argv) < 2 or len(sys.argv) > 3:
    print(f"Usage: {sys.argv[0]} <original filename> [output filename]")
    sys.exit(1)

# The original filename used in encryption (e.g. "immagine0.png")
original_file = sys.argv[1]
# Optional: specify an output filename; if not provided, use "decrypted_<original filename>"
output_file = sys.argv[2] if len(sys.argv) == 3 else "decrypted_" + os.path.basename(original_file)

# Derive the key using the same method as encryption
key = sha256(original_file.encode()).digest()
iv = b'\x00' * 16  # constant IV as used in encryption

# Find all encrypted chunk files in the current directory matching the pattern.
pattern = f"{original_file}_*.enc"
chunk_files = glob.glob(pattern)
if not chunk_files:
    print(f"No encrypted files found matching pattern '{pattern}'")
    sys.exit(1)

# Sorting the files ensures that they are processed in order
chunk_files.sort()

with open(output_file, "wb") as out_f:
    for chunk_file in chunk_files:
        with open(chunk_file, "rb") as f:
            enc_data = f.read()
            cipher = AES.new(key, AES.MODE_CBC, iv)
            dec_data = cipher.decrypt(enc_data)
            try:
                # Remove padding from the decrypted data
                chunk = unpad(dec_data, AES.block_size)
            except ValueError as e:
                print(f"Error unpadding file {chunk_file}: {e}")
                sys.exit(1)
            out_f.write(chunk)

print(f"Decryption complete. Output written to {output_file}")
